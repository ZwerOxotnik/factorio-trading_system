---@class TradingSystem : module
local M = {}


--#region Global data

---@class mod_data
---@type table<string, any>
local __mod_data

-- {[item name] = price}
---@class global_sell_prices
---@type table<string, uint>
local __global_sell_prices

-- {[item name] = price}
---@class global_buy_prices
---@type table<string, uint>
local __global_buy_prices

-- {force index = {[item name] = price}}
---@class sell_prices
---@type table<uint, table<string, uint>>
local __sell_prices

-- {force index = {[item name] = price}}
---@class buy_prices
---@type table<uint, table<string, uint>>
local __buy_prices

-- {[force index] = uint}
---@type table<uint, uint>
local __last_sell_id

-- {[force index] = uint}
---@type table<uint, uint>
local __last_buy_id

-- {[force index] = {[item name] = LuaEntity[]}}
---@class buy_markets
---@type table<uint, table<string, LuaEntity[]>>
local __buy_markets

-- {[force index] = {[item name] = LuaEntity[]}}
---@class buy_markets
---@type table<uint, table<string, LuaEntity[]>>
local __sell_markets

-- {[force index] = string[]}
---@class buy_catalogue
---@type table<uint, string[]>
local __buy_catalogue

-- {[force index] = string[]}
---@class sell_catalogue
---@type table<uint, string[]>
local __sell_catalogue


---@class market_data
---@field [1] LuaEntity # storage
---@field [2] LuaEntity # hidden market
---@field [3] uint # market_type
---@field [4] string? # item name

---@class all_markets
---@type table<uint, market_data>
local __all_markets


---@class hidden_market_data
---@field [1] LuaEntity # market
---@field [2] LuaEntity # storage
---@field [3] uint? # id update

---@class all_hidden_markets
---@type table<uint, hidden_market_data>
local __all_hidden_markets

--#endregion


--#region Constants
local tremove = table.remove
local call = remote.call
local floor = math.floor
local print_to_rcon = rcon.print
--#if IGNORE_MACROSES then
	local SELL_TYPE = 2
	local BUY_TYPE = 1
--#else
	--#define("SELL_TYPE", "2")
	--#define("BUY_TYPE", "1")
--#end
---@type LuaEntity.destroy_param
local DESTROY_PARAM = {raise_destroy = true}
local MARKETS_TYPES = {
	["TSZO_sell_container_3x2"] = SELL_TYPE,
	["TSZO_buy_container_3x2"]  = BUY_TYPE,
}
local HIDDEN_MARKETS_TYPES = {
	["TSZO_hidden_sell_market_3x2"] = SELL_TYPE,
	["TSZO_hidden_buy_market_3x2"]  = BUY_TYPE,
}
local MARKETS_TO_HIDDEN = {
	["TSZO_sell_container_3x2"] = "TSZO_hidden_sell_market_3x2",
	["TSZO_buy_container_3x2"]  = "TSZO_hidden_buy_market_3x2",
}

---@type table<string, uint>
local DEFAULT_SELL_PRICES = {}
for mod_name in pairs(script.active_mods) do
	local _is_ok, _price_list = pcall(require, string.format("__%s__/sell_prices_for_trading_system", mod_name))
	if _is_ok and type(_price_list) == "table" then
		for name, price in pairs(_price_list) do
			if type(name) == "string" and type(price) == "number" and price >= 1 then
				DEFAULT_SELL_PRICES[name] = math.floor(price) --[[@as uint]]
			end
		end
	end
end

---@type table<string, uint>
local DEFAULT_BUY_PRICES = {}
for mod_name in pairs(script.active_mods) do
	local _is_ok, _price_list = pcall(require, string.format("__%s__/buy_prices_for_trading_system", mod_name))
	if _is_ok and type(_price_list) == "table" then
		for name, price in pairs(_price_list) do
			if type(name) == "string" and type(price) == "number" and price >= 1 then
				DEFAULT_BUY_PRICES[name] = math.floor(price) --[[@as uint]]
			end
		end
	end
end

--#endregion


--#region Settings
local _update_buy_tick  = settings.global["TSZO_update-buy-tick"].value --[[@as uint]]
local _update_sell_tick = settings.global["TSZO_update-sell-tick"].value --[[@as uint]]
--#endregion


--- It's not safe to set count above ~4000000000
---@type SimpleItemStack
local _buy_stack = {name = "", count = 0}

--- It's not safe to set count above ~4000000000
---@type SimpleItemStack
local _sell_stack = {name = "", count = 4000000000}

--#region Global functions


---@param price number
---@return boolean
local function is_price_valid(price)
	return (price >= 0 and price < 65535)
end


---@param target  LuaForce|LuaPlayer # From whom the data?
---@param getter? LuaForce|LuaPlayer # Print to whom? (game by default)
function print_force_data(target, getter)
	if getter then
		if not getter.valid then
			log("Invalid object")
			return
		end
	else
		getter = game
	end

	local index
	local object_name = target.object_name
	if object_name == "LuaPlayer" then
		index = target.force_index
	elseif object_name == "LuaForce" then
		index = target.index
	else
		log("Invalid type")
		return
	end

	local print_to_target = getter.print
	print_to_target('')
	print_to_target("Sell prices:" .. serpent.line(__sell_prices[index]))
	print_to_target("Buy prices:"  .. serpent.line(__buy_prices[index]))
	print_to_target("Sell markets:" .. serpent.line(__sell_markets[index]))
	print_to_target("Buy markets:" .. serpent.line(__buy_markets[index]))
	print_to_target("Sell catalogue:" .. serpent.line(__sell_catalogue[index]))
	print_to_target("Buy catalogue:" .. serpent.line(__buy_catalogue[index]))
	print_to_target("_last_sell_id:" .. tostring(__last_sell_id[index]or ""))
	print_to_target("_last_buy_id:" .. tostring(__last_buy_id[index] or ""))
end


---@param local_data table
---@param global_data_name string
---@param receiver table?
---@return boolean
function check_local_and_global_data(local_data, global_data_name, receiver)
	if (type(global_data_name) == "string" and local_data ~= storage.TSZO[global_data_name]) then
		local message = string.format("!WARNING! Desync has been detected in __%s__ %s. Please report and send log files to %s and try to load your game again or use /sync", script.mod_name, "mod_data[\"" .. global_data_name .. "\"]", "ZwerOxotnik")
		log(message)
		if game and (game.is_multiplayer() == false or receiver) then
			message = {"EasyAPI.report-desync",
				script.mod_name, "mod_data[\"" .. global_data_name .. "\"]", "ZwerOxotnik"
			}
			receiver = receiver or game
			receiver.print(message)
		end
		return true
	end
	return false
end


---@param receiver table?
function detect_desync(receiver)
	check_local_and_global_data(__sell_prices, "sell_prices", receiver)
	check_local_and_global_data(__buy_prices, "buy_prices", receiver)
	check_local_and_global_data(__buy_markets, "buy_markets", receiver)
	check_local_and_global_data(__sell_markets, "sell_markets", receiver)
	check_local_and_global_data(__buy_catalogue, "buy_catalogue", receiver)
	check_local_and_global_data(__sell_catalogue, "sell_catalogue", receiver)
	check_local_and_global_data(__last_sell_id, "last_sell_id", receiver)
	check_local_and_global_data(__last_buy_id, "last_buy_id", receiver)
	check_local_and_global_data(__global_sell_prices, "global_sell_prices", receiver)
	check_local_and_global_data(__global_buy_prices, "global_buy_prices", receiver)
	check_local_and_global_data(__all_markets, "all_markets", receiver)
	check_local_and_global_data(__all_hidden_markets, "all_hidden_markets", receiver)
end

--#endregion


--#region Function for RCON

---@param name string
function getRconData(name)
	print_to_rcon(helpers.table_to_json(__mod_data[name]))
end

---@param name string
---@param force LuaForce
function getRconForceData(name, force)
	if not force.valid then return end
	print_to_rcon(helpers.table_to_json(__mod_data[name][force.index]))
end

---@param name string
---@param force_index integer
function getRconForceDataByIndex(name, force_index)
	print_to_rcon(helpers.table_to_json(__mod_data[name][force_index]))
end

--#endregion


--#region utils


---@param json_text string?
---@param table_data table? # do not use it remote interfaces
function import_global_prices(json_text, table_data)
	local table_data = table_data or helpers.json_to_table(json_text)
	if table_data == nil or type(table_data) ~= "table" then return end

	local item_prototypes = prototypes.item
	if table_data.global_buy_prices then
		local new_prices = table_data.global_buy_prices
		for item_name in pairs(new_prices) do
			if not item_prototypes[item_name] then
				new_prices[item_name] = nil
			end
		end

		__mod_data.global_buy_prices = new_prices
		__global_buy_prices = __mod_data.global_buy_prices

		for force_index in pairs(__buy_markets) do
			__buy_markets[force_index] = {}
		end

		for force_index in pairs(__buy_prices) do
			---@type string[]
			local new_price_list = {nil}
			for item_name, price in pairs(new_prices) do
				new_price_list[item_name] = price
			end
			__buy_prices[force_index] = new_price_list
		end

		for force_index in pairs(__buy_catalogue) do
			---@type string[]
			local new_catalogue = {nil}
			for item_name in pairs(new_prices) do
				new_catalogue[#new_catalogue+1] = item_name
			end
			__buy_catalogue[force_index] = new_catalogue
			__last_buy_id[force_index] = __last_buy_id[force_index] + 1
		end

		for _, market_data in pairs(__all_markets) do
			if market_data[3] == BUY_TYPE then
				local market = market_data[2]
				local item_name = market_data[4]
				if item_name then
					if new_prices[item_name] then
						M.set_force_buy_market(item_name, market_data[1])
					else
						market_data[4] = nil
					end
				end
				__all_hidden_markets[market.unit_number][3] = nil -- remove id update
			end
		end
	end

	if table_data.global_sell_prices then
		local new_prices = table_data.global_sell_prices
		for item_name in pairs(new_prices) do
			if not item_prototypes[item_name] then
				new_prices[item_name] = nil
			end
		end

		__mod_data.global_sell_prices = new_prices
		__global_sell_prices = __mod_data.global_sell_prices

		for force_index in pairs(__sell_markets) do
			__sell_markets[force_index] = {}
		end

		for force_index in pairs(__sell_prices) do
			---@type string[]
			local new_price_list = {nil}
			for item_name, price in pairs(new_prices) do
				new_price_list[item_name] = price
			end
			__sell_prices[force_index] = new_price_list
		end

		for force_index in pairs(__sell_catalogue) do
			---@type string[]
			local new_catalogue = {nil}
			for item_name in pairs(new_prices) do
				new_catalogue[#new_catalogue+1] = item_name
			end
			__sell_catalogue[force_index] = new_catalogue
			__last_sell_id[force_index] = __last_sell_id[force_index] + 1
		end

		for _, market_data in pairs(__all_markets) do
			if market_data[3] == SELL_TYPE then
				local market = market_data[2]
				local item_name = market_data[4]
				if item_name then
					if new_prices[item_name] then
						M.set_force_sell_market(item_name, market_data[1])
					else
						market_data[4] = nil
					end
				end
				__all_hidden_markets[market.unit_number][3] = nil -- remove id update
			end
		end
	end
end


---@param index number
function clear_force_data(index)
	local force = game.forces[index]
	if force then
		for _, market_data in pairs(__all_markets) do
			local storage = market_data[1]
			if storage.valid and storage.force == force then
				local market = market_data[2]
				if market.valid then
					__all_hidden_markets[market.unit_number][3] = nil -- remove id update
				end
				market_data[4] = nil -- remove item name
			end
		end
	end

	__buy_catalogue[index]  = nil
	__sell_catalogue[index] = nil
	__sell_prices[index]  = nil
	__buy_prices[index]   = nil
	__buy_markets[index]  = nil
	__sell_markets[index] = nil
	__last_sell_id[index] = nil
	__last_buy_id[index]  = nil
end


---@param index number
function init_force_data(index)
	__buy_catalogue[index]  = __buy_catalogue[index]  or {}
	__sell_catalogue[index] = __sell_catalogue[index] or {}
	__sell_prices[index]  = __sell_prices[index]  or {}
	__buy_prices[index]   = __buy_prices[index]   or {}
	__buy_markets[index]  = __buy_markets[index]  or {}
	__sell_markets[index] = __sell_markets[index] or {}
	__last_sell_id[index] = __last_sell_id[index] or 0
	__last_buy_id[index]  = __last_buy_id[index]  or 0
end


-- TODO: improve (use global data)
---@param force_index uint?
function disable_mod_recipes(force_index)
	__mod_data.is_recipes_disabled = false

	if force_index == nil then
		for _, force in pairs(game.forces) do
			force.recipes["TSZO_sell_container_3x2"].enabled = false
			force.recipes["TSZO_buy_container_3x2"].enabled  = false
		end
	end

	local force = game.forces[force_index]
	if not (force and force.valid) then return end
	force.recipes["TSZO_sell_container_3x2"].enabled = false
	force.recipes["TSZO_buy_container_3x2"].enabled  = false
end


-- TODO: improve (use global data)
---@param force_index uint?
function enable_mod_recipes(force_index)
	__mod_data.is_recipes_disabled = true

	if force_index == nil then
		for _, force in pairs(game.forces) do
			force.recipes["TSZO_sell_container_3x2"].enabled = true
			force.recipes["TSZO_buy_container_3x2"].enabled  = true
		end
	end

	local force = game.forces[force_index]
	if not (force and force.valid) then return end
	force.recipes["TSZO_sell_container_3x2"].enabled = true
	force.recipes["TSZO_buy_container_3x2"].enabled  = true
end


---@param text string
---@return string?, uint?
function M.find_item_in_text(text)
	local args = {}
	for arg in string.gmatch(text, "%g+") do args[#args+1] = arg end

	local item_name
	local count_index = 1
	local count = tonumber(args[count_index])
	if count == nil then
		count_index = 2
		count = tonumber(args[count_index])
	end
	---@cast count uint?

	if count == nil then
		item_name = text
	else
		if count_index == 1 then
			item_name = args[2]
		elseif count_index == 2 then
			item_name = args[1]
		end
	end

	local prototype = prototypes.item[item_name]
	if prototype == nil then
		item_name = string.gsub(item_name, ".*%[item=(.+)%].*", "%1")
		if item_name == nil then
			return
		end
		prototype = prototypes.item[item_name]
		if prototype == nil then
			return
		end
	end
	if count and count <= 0 then
		count = nil
	end

	return item_name, count
end


---@param item_name string
---@param price uint?
---@return boolean
function set_buy_price_globally(item_name, price)
	if price and not is_price_valid(price) then return false end

	__global_buy_prices[item_name] = price
	for force_index in pairs(__buy_prices) do
		set_force_buy_price(force_index, item_name, price)
	end

	return true
end


---@param item_name string
---@param price uint?
---@return boolean
function set_sell_price_globally(item_name, price)
	if price and not is_price_valid(price) then return false end

	__global_sell_prices[item_name] = price
	for force_index in pairs(__sell_prices) do
		set_force_sell_price(force_index, item_name, price)
	end

	return true
end


---@param force_index uint
---@param item_name string
---@param price uint?
---@return boolean
function set_force_sell_price(force_index, item_name, price)
	local f_sell_prices = __sell_prices[force_index]
	if f_sell_prices == nil then return false end

	if price and not is_price_valid(price) then return false end

	local prev_price = f_sell_prices[item_name]
	f_sell_prices[item_name] = price
	if (prev_price == nil and price) or (prev_price and price == nil) then
		---@type string[]
		local new_catalogue = {nil}
		local prices = __sell_prices[force_index]
		for _item_name in pairs(prices) do
			new_catalogue[#new_catalogue+1] = _item_name
		end
		__sell_catalogue[force_index] = new_catalogue
	end

	if price == nil then
		local markets = __sell_markets[force_index]
		if markets and markets[item_name] then
			markets[item_name] = nil
		end
	end

	__last_sell_id[force_index] = __last_sell_id[force_index] + 1

	return true
end


---@param force_index uint
---@param item_name string
---@param price uint?
---@return boolean
function set_force_buy_price(force_index, item_name, price)
	local f_buy_prices = __buy_prices[force_index]
	if f_buy_prices == nil then return false end

	if price and not is_price_valid(price) then return false end

	local prev_price = f_buy_prices[item_name]
	f_buy_prices[item_name] = price
	if prev_price == nil and price or prev_price and price == nil then
		---@type string[]
		local new_catalogue = {nil}
		local prices = __buy_prices[force_index]
		for _item_name in pairs(prices) do
			new_catalogue[#new_catalogue+1] = _item_name
		end
		__buy_catalogue[force_index] = new_catalogue
	end

	if price == nil then
		local markets = __buy_markets[force_index]
		if markets and markets[item_name] then
			markets[item_name] = nil
		end
	end

	__last_buy_id[force_index] = __last_buy_id[force_index] + 1

	return true
end


---@param entity LuaEntity
function M.remove_hidden_market(entity)
	if entity.valid then
		__all_hidden_markets[entity.unit_number] = nil
		entity.destroy(DESTROY_PARAM)
	end
end


---@param entity LuaEntity
---@param markets_data buy_markets | sell_markets
---@param market_data market_data?
function M.remove_market_from_markets(entity, markets_data, market_data)
	local force_index = entity.force_index
	market_data = market_data or __all_markets[entity.force_index]
	local item_name = market_data[4]
	if item_name == nil then return end
	local markets = markets_data[force_index]
	local entities = markets[item_name]
	if entities == nil then return end

	for i = #entities, 1, -1 do
		if entities[i] == entity then
			if #entities == 1 then
				markets[item_name] = nil
			else
				tremove(entities, i)
			end
			return
		end
	end
end


---@param entity LuaEntity
---@param market_data market_data
function M.remove_certain_buy_market(entity, market_data)
	__all_markets[entity.unit_number] = nil
	M.remove_market_from_markets(entity, __buy_markets, market_data)
	M.remove_hidden_market(market_data[2])
end


---@param entity LuaEntity
---@param market_data market_data
function M.remove_certain_sell_market(entity, market_data)
	__all_markets[entity.unit_number] = nil
	M.remove_market_from_markets(entity, __sell_markets, market_data)
	M.remove_hidden_market(market_data[2])
end


---@param prices global_buy_prices|global_sell_prices?
local function clear_invalid_global_prices(prices)
	if prices == nil then
		clear_invalid_global_prices(__global_sell_prices)
		clear_invalid_global_prices(__global_buy_prices)
		return
	end
	---@cast prices global_buy_prices|global_sell_prices

	local item_prototypes = prototypes.item
	for item_name in pairs(prices) do
		if item_prototypes[item_name] == nil then
			prices[item_name] = nil
		end
	end
end


---@param prices buy_prices|sell_prices?
local function clear_invalid_prices(prices)
	if prices == nil then
		clear_invalid_prices(__buy_prices)
		clear_invalid_prices(__sell_prices)
		return
	end
	---@cast prices buy_prices|sell_prices

	local item_prototypes = prototypes.item
	local forces = game.forces
	for index, forces_data in pairs(prices) do
		if forces[index] == nil then
			prices[index] = nil
		else
			for item_name in pairs(forces_data) do
				if item_prototypes[item_name] == nil then
					forces_data[item_name] = nil
				end
			end
		end
	end
end


---@param markets buy_markets|sell_markets?
function clear_invalid_markets_data(markets)
	if markets == nil then
		clear_invalid_markets_data(__sell_markets)
		clear_invalid_markets_data(__buy_markets)
		return
	end
	---@cast markets buy_markets|sell_markets

	local item_prototypes = prototypes.item
	local forces = game.forces
	for force_index, force_data in pairs(markets) do
		if forces[force_index] == nil then
			clear_force_data(force_index) -- maybe it's wrong
		else
			for item_name, entities in pairs(force_data) do
				if item_prototypes[item_name] == nil then
					force_data[item_name] = nil
					goto continue
				end
				for i=#entities, 1, -1 do
					local entity = entities[i]
					if entity.valid == false then
						tremove(entities, i)
					else
						local _market_data = __all_markets[entity.unit_number]
						if _market_data == nil then
							tremove(entities, i)
						elseif entity ~= _market_data[1] then
							__all_markets[entity.unit_number] = nil
							tremove(entities, i)
						end
					end
				end
				if #entities == 0 then
					force_data[item_name] = nil
				end
				::continue::
			end
		end
	end
end

---@param catalogue buy_catalogue|sell_catalogue?
function clear_invalid_catalogue(catalogue)
	if catalogue == nil then
		clear_invalid_catalogue(__sell_catalogue)
		clear_invalid_catalogue(__buy_catalogue)
		return
	end
	---@cast catalogue buy_catalogue|sell_catalogue

	local item_prototypes = prototypes.item
	local forces = game.forces
	for index, items in pairs(catalogue) do
		if forces[index] == nil then
			catalogue[index] = nil
			goto continue
		end
		for i=#items, 1, -1 do
			local item_name = items[i]
			if item_prototypes[item_name] == nil then
				tremove(items, i)
			end
		end
	    ::continue::
	end
end

function clear_invalid_entities()
	local item_prototypes = prototypes.item
	for unit_number, data in pairs(__all_markets) do
		local storage = data[1]
		if not storage.valid then
			__all_markets[unit_number] = nil
		elseif not data[2].valid then
			M.remove_hidden_market(data[2])
			__all_markets[unit_number] = nil
		else
			local item_name = data[4]
			if item_name and item_prototypes[item_name] == nil then
				local market_type = data[3]
				if market_type == BUY_TYPE then
					M.remove_market_from_markets(storage, __buy_markets, data)
				elseif market_type == SELL_TYPE then
					M.remove_market_from_markets(storage, __sell_markets, data)
				end
				data[4] = nil -- remove item name
			end
		end
	end

	for unit_number, data in pairs(__all_hidden_markets) do
		local market = data[1]
		if not market.valid or not data[2].valid then
			__all_hidden_markets[unit_number] = nil
		end
	end

	clear_invalid_markets_data()
end


function clear_invalid_data()
	clear_invalid_global_prices()
	clear_invalid_prices()
	clear_invalid_catalogue()
	clear_invalid_entities()
end


---@param storage LuaEntity
---@param market_type unit
M.create_force_market = function(storage, market_type)
	local hidden_market = storage.surface.create_entity{
		name = MARKETS_TO_HIDDEN[storage.name],
		force = storage.force,
		position = storage.position
	}
	hidden_market.minable = false
	hidden_market.destructible = false
	hidden_market.rotatable = false

	__all_markets[storage.unit_number] = {
		storage, hidden_market, market_type, nil
	}
	__all_hidden_markets[hidden_market.unit_number] = {
		hidden_market, storage, nil
	}
end


---@param item_name string
---@param entity LuaEntity
---@param count? number
function M.set_force_buy_market(item_name, entity, count)
	-- count = count or prototypes.item[item_name].stack_size * 11

	local market_data = __all_markets[entity.unit_number]
	local force_index = entity.force.index
	local f_buy_markets = __buy_markets[force_index]
	local prev_item_name = market_data[4]
	if prev_item_name then
		if prev_item_name == item_name then return end
		local _entities = f_buy_markets[prev_item_name]
		for i = #_entities, 1, -1 do
			if _entities[i] == entity then
				if #_entities == 1 then
					f_buy_markets[prev_item_name] = nil
				else
					tremove(_entities, i)
				end
				break
			end
		end
	end

	local entities = f_buy_markets[item_name]
	if entities == nil then
		f_buy_markets[item_name] = {entity}
	else
		entities[#entities+1] = entity
	end

	market_data[4] = item_name
end


---@param item_name string
---@param entity LuaEntity
function M.set_force_sell_market(item_name, entity)
	local market_data = __all_markets[entity.unit_number]
	local force_index = entity.force.index
	local f_sell_markets = __sell_markets[force_index]
	local prev_item_name = market_data[4]
	if prev_item_name then
		if prev_item_name == item_name then return end
		local _entities = f_sell_markets[prev_item_name]
		for i = #_entities, 1, -1 do
			if _entities[i] == entity then
				if #_entities == 1 then
					f_sell_markets[prev_item_name] = nil
				else
					tremove(_entities, i)
				end
				break
			end
		end
	end

	local entities = f_sell_markets[item_name]
	if entities == nil then
		f_sell_markets[item_name] = {entity}
	else
		entities[#entities+1] = entity
	end

	market_data[4] = item_name
end


---@type Ingredient
local __market_buy_f_price = {name = "coin", count = 0}
---@type TechnologyModifier
local __market_buy_f_offer = {type="give-item", item=""}
---@type Offer
local __market_f_buy_trade = {
	price = {__market_buy_f_price},
	offer = __market_buy_f_offer
}
---@param entity LuaEntity
---@param market_data hidden_market_data
function M.add_force_items_for_buy_market(entity, market_data)
	local force_index = entity.force.index

	local prices = __buy_prices[force_index]
	local add_market_item = entity.add_market_item
	for item_name, price in pairs(prices) do
		__market_buy_f_price.count = price
		__market_buy_f_offer.item  = item_name
		add_market_item(__market_f_buy_trade)
	end
	market_data[3] = __last_buy_id[force_index]
end


---@type Ingredient
local __market_sell_f_price = {name = "", count = 1}
---@type TechnologyModifier
local __market_sell_f_offer = {type="give-item", item="coin", count = 1}
---@type Offer
local __market_f_sell_trade = {
	price = {__market_sell_f_price},
	offer = __market_sell_f_offer
}
---@param entity LuaEntity
---@param market_data hidden_market_data
function M.add_force_items_for_sell_market(entity, market_data)
	local force_index = entity.force.index

	local prices = __sell_prices[force_index]
	local add_market_item = entity.add_market_item
	for item_name, price in pairs(prices) do
		__market_sell_f_offer.count = price
		__market_sell_f_price.name  = item_name
		add_market_item(__market_f_sell_trade)
	end
	market_data[3] = __last_sell_id[force_index]
end


local REMOVE_MARKETS_FUNCS = {
	[BUY_TYPE] = M.remove_certain_buy_market,
	[SELL_TYPE] = M.remove_certain_sell_market
}
---@param entity LuaEntity
function clear_market_data_by_entity(entity)
	local market_data = __all_markets[entity.unit_number]
	if market_data == nil then return end

	REMOVE_MARKETS_FUNCS[market_data[3]](entity, market_data)
	return true
end

--#endregion


--#region Functions of events

function M.clear_market_data(event)
	local entity = event.entity
	if not entity.valid then return end
	local market_data = __all_markets[entity.unit_number]
	if market_data == nil then return end

	REMOVE_MARKETS_FUNCS[market_data[3]](entity, market_data)
end


function M.on_player_joined_game(event)
	local player = game.get_player(event.player_index)
	if not (player and player.valid) then return end

	if #game.connected_players == 1 then
		detect_desync()
	end
end


function M.on_force_created(event)
	local force = event.force
	if not force.valid then return end

	local force_index = force.index
	init_force_data(force_index)

	if __mod_data.is_recipes_disabled then
		disable_mod_recipes(force_index)
	end
end


M.on_forces_merging = function(event)
	local source_force = event.source
	if not source_force.valid then return end

	local source_index = source_force.index
	clear_force_data(source_index)
end


---@param event on_built_entity | on_robot_built_entity
M.on_built_entity = function(event)
	local entity = event.entity
	if not entity.valid then return end
	local market_type = MARKETS_TYPES[entity.name]
	if market_type == nil then return end

	M.create_force_market(entity, market_type)
end


---@param event script_raised_built
M.script_raised_built = function(event)
	local entity = event.entity
	if not entity.valid then return end

	local market_type = MARKETS_TYPES[entity.name]
	if market_type == nil then return end

	M.create_force_market(entity, market_type)
end


---@param event on_entity_cloned
function M.on_entity_cloned(event)
	local source = event.source
	if not source.valid then return end

	local destination = event.destination
	if not destination.valid then return end

	local market_data
	if source.type == "market" then
		if __all_hidden_markets[source.unit_number] then
			destination.destroy(DESTROY_PARAM)
		end
	else -- container
		market_data = __all_markets[source.unit_number]
	end
	if market_data == nil then return end

	M.create_force_market(destination, MARKETS_TYPES[destination.name])
end


---@param event on_market_item_purchased
function M.on_market_item_purchased(event)
	local entity = event.market
	if not (entity and entity.valid) then return end
	---@cast entity LuaEntity
	local market_type = HIDDEN_MARKETS_TYPES[entity.name]
	if market_type == nil then return end
	local player = game.get_player(event.player_index)
	if not (player and player.valid) then return end
	local market_data = __all_hidden_markets[entity.unit_number]
	if not market_data then return end

	local force_index = entity.force.index
	if market_type == BUY_TYPE then
		local item_name = __buy_catalogue[force_index][event.offer_index]
		M.set_force_buy_market(item_name, market_data[2])
	elseif market_type == SELL_TYPE then
		local item_name = __sell_catalogue[force_index][event.offer_index]
		M.set_force_sell_market(item_name, market_data[2])
	end
end


-- TODO: Recheck it in Factorio 1.2.*
---@param event on_gui_opened
M.on_gui_opened = function(event)
	local entity = event.entity
	if not (entity and entity.valid) then return end
	local market_type = HIDDEN_MARKETS_TYPES[entity.name]
	if market_type == nil then return end
	local player = game.get_player(event.player_index)
	if not (player and player.valid) then return end
	local market_data = __all_hidden_markets[entity.unit_number]
	if not market_data then return end
	local entity_force = entity.force
	if entity_force ~= player.force then
		player.opened = nil
		return
	end

	local market_buy_id = market_data[2]
	if market_buy_id ~= nil then
		entity.clear_market_items()
	elseif market_type == BUY_TYPE then
		if __last_buy_id[entity_force.index] == market_buy_id then
			return
		end
	elseif market_type == SELL_TYPE then
		if __last_sell_id[entity_force.index] == market_buy_id then
			return
		end
	end

	if market_type == BUY_TYPE then
		M.add_force_items_for_buy_market(entity, market_data)
	elseif market_type == SELL_TYPE then
		M.add_force_items_for_sell_market(entity, market_data)
	end
end


function M.check_buy_markets()
	local last_checked_index = __mod_data.last_checked_index
	local buyer_index
	buyer_index, buyer_index = next(__buy_markets, last_checked_index)
	__mod_data.last_checked_index = buyer_index
	if buyer_index == nil then
		return
	end

	local items_data = __buy_markets[buyer_index]
	-- TODO: improve \/
	if items_data == nil then return end

	local forces_money = call("EasyAPI", "get_forces_money")
	---@cast forces_money table<uint, integer>
	local buyer_money = forces_money[buyer_index]
	if buyer_money == nil or buyer_money <= 0 then
		return
	end

	local stack_count = 0 -- for optimization
	local f_buy_prices = __buy_prices[buyer_index]
	local inserted_count_in_total = 0
	for item_name, entities in pairs(items_data) do
		if 0 >= buyer_money then
			-- TODO: improve
			goto not_enough_money
		end
		local buy_price = f_buy_prices[item_name]
		if buy_price and buyer_money >= buy_price then
			for i=#entities, 1, -1 do
				local buy_market = entities[i]
				--#if EXTRA_STABILITY then
					if not buy_market.valid then
						tremove(entities, i)
						goto skip_buy
					end
				--#end
				local purchasable_count = buyer_money / buy_price
				if purchasable_count < 1 then
					goto skip_buy
				else
					purchasable_count = floor(purchasable_count)
				end
				local need_count = 60 * 11 -- TODO: change and check
				if purchasable_count < need_count then
					need_count = purchasable_count
				end
				local count = buy_market.get_item_count(item_name)
				_buy_stack["name"] = item_name
				if need_count >= count then
					need_count = need_count - count
					if need_count <= 0 then
						goto skip_buy
					end
				end
				local found_items = need_count - stack_count
				if found_items > 0 then
					_buy_stack["count"] = found_items
					local inserted_count = buy_market.insert(_buy_stack)
					inserted_count_in_total = inserted_count_in_total + inserted_count
					buyer_money = buyer_money - (inserted_count * buy_price)
				end
				:: skip_buy ::
			end
		end
	end
	:: not_enough_money ::
	forces_money[buyer_index] = buyer_money

	local forces = game.forces
	call("EasyAPI", "set_forces_money", forces_money)
	for _force_index, money in pairs(forces_money) do
		local prev_money = forces_money[_force_index]
		if prev_money ~= money then
			local force = forces[_force_index]
			force.item_production_statistics.on_flow("trading", money - prev_money)
		end
	end
end


function M.check_sell_markets()
	local forces_money = call("EasyAPI", "get_forces_money")
	---@cast forces_money table<uint, integer>

	for force_index, _items_data in pairs(__sell_markets) do
		local money = forces_money[force_index]
		if money == nil then
			goto skip_force
		end

		local prices = __sell_prices[force_index]
		for item_name, entities in pairs(_items_data) do
			local sell_price = prices[item_name]
			_sell_stack.name = item_name
			for i = 1, #entities do
				local entity = entities[i]
				--#if EXTRA_STABILITY then
					if not entity.valid then
						tremove(entities, i)
						goto skip_selling
					end
				--#end
				money = money + sell_price * entity.remove_item(_sell_stack)
				:: skip_selling ::
			end
		end
		forces_money[force_index] = money

		:: skip_force ::
	end

	call("EasyAPI", "set_forces_money", forces_money)
end


---@param event on_player_changed_force
function M.on_player_changed_force(event)
	local player_index = event.player_index
	local player = game.get_player(player_index)
	if not (player and player.valid) then return end

	local force_index = player.force_index
	if __buy_markets[force_index] == nil then
		init_force_data(force_index)
	end
end

local mod_settings = {
	["TSZO_update-buy-tick"] = function(value)
		if _update_sell_tick == value then
			settings.global["TSZO_update-buy-tick"] = {
				value = value + 1
			}
			return
		end
		script.on_nth_tick(_update_buy_tick, nil)
		_update_buy_tick = value
		script.on_nth_tick(value, M.check_buy_markets)
	end,
	["TSZO_update-sell-tick"] = function(value)
		if _update_buy_tick == value then
			settings.global["TSZO_update-sell-tick"] = {
				value = value + 1
			}
			return
		end
		script.on_nth_tick(_update_sell_tick, nil)
		_update_sell_tick = value
		script.on_nth_tick(value, M.check_buy_markets)
	end,
}
function M.on_runtime_mod_setting_changed(event)
	local setting_name = event.setting
	local f = mod_settings[setting_name]
	if f == nil then return end

	if event.setting_type == "runtime-global" then
		f(settings.global[setting_name].value)
	else
		local player = game.get_player(event.player_index)
		if player and player.valid then
			f(player)
		end
	end
end

--#endregion


--#region Pre-game stage

local function add_remote_interface()
	-- https://lua-api.factorio.com/latest/LuaRemote.html
	remote.remove_interface("trading_system") -- For safety
	remote.add_interface("trading_system", {
		get_mod_data = function() return __mod_data end,
		get_internal_data = function(name) return __mod_data[name] end,
		import_global_prices = import_global_prices,
		clear_invalid_data = clear_invalid_data,
		clear_invalid_entities = clear_invalid_entities,
		remove_certain_sell_market  = M.remove_certain_sell_market,
		remove_certain_buy_market   = M.remove_certain_buy_market,
		clear_market_data_by_entity = clear_market_data_by_entity,
		clear_force_data = clear_force_data,
		init_force_data  = init_force_data,
		set_force_sell_market = M.set_force_sell_market,
		set_force_buy_market  = M.set_force_buy_market,
		set_sell_price_globally = set_sell_price_globally,
		set_buy_price_globally  = set_buy_price_globally,
		set_force_sell_price = set_force_sell_price,
		set_force_buy_price  = set_force_buy_price,
		disable_mod_recipes = disable_mod_recipes,
		enable_mod_recipes  = enable_mod_recipes,
		create_force_market = M.create_force_market,
		remove_market_from_markets = M.remove_market_from_markets,
		get_sell_markets  = function() return __sell_markets end,
		get_buy_markets   = function() return __buy_markets end,
		get_sell_prices   = function() return __sell_prices end,
		get_buy_prices    = function() return __buy_prices end,
		get_all_markets   = function() return __all_markets end,
	})
end

local function link_data()
	__mod_data = storage.TSZO
	__buy_markets  = __mod_data.buy_markets
	__sell_markets = __mod_data.sell_markets
	__buy_catalogue  = __mod_data.buy_catalogue
	__sell_catalogue = __mod_data.sell_catalogue
	__last_sell_id = __mod_data.last_sell_id
	__last_buy_id  = __mod_data.last_buy_id
	__sell_prices = __mod_data.sell_prices
	__buy_prices  = __mod_data.buy_prices
	__global_sell_prices = __mod_data.global_sell_prices
	__global_buy_prices  = __mod_data.global_buy_prices
	__all_hidden_markets = __mod_data.all_hidden_markets
	__all_markets = __mod_data.all_markets

	local id = call("EasyAPI", "get_event_name", "on_entity_changed_force")
	script.on_event(id, M.clear_market_data)
end

local function update_global_data()
	storage.TSZO = storage.TSZO or {}
	__mod_data = storage.TSZO
	__mod_data.is_recipes_disabled = __mod_data.is_recipes_disabled or false
	__mod_data.buy_markets  = __mod_data.buy_markets or {}
	__mod_data.sell_markets = __mod_data.sell_markets or {}
	__mod_data.buy_catalogue  = __mod_data.buy_catalogue or {}
	__mod_data.sell_catalogue = __mod_data.sell_catalogue or {}
	__mod_data.sell_prices = __mod_data.sell_prices or {}
	__mod_data.buy_prices  = __mod_data.buy_prices or {}

	local item_prototypes = prototypes.item
	if __mod_data.global_sell_prices == nil then
		local new_price_list = {}
		for name, price in pairs(DEFAULT_SELL_PRICES) do
			if item_prototypes[name] then
				new_price_list[name] = price
			end
		end
		__mod_data.global_sell_prices = new_price_list
	end
		if __mod_data.global_buy_prices == nil then
		local new_price_list = {}
		for name, price in pairs(DEFAULT_BUY_PRICES) do
			if item_prototypes[name] then
				new_price_list[name] = price
			end
		end
		__mod_data.global_buy_prices = new_price_list
	end

	__mod_data.last_sell_id = __mod_data.last_sell_id or {}
	__mod_data.last_buy_id  = __mod_data.last_buy_id or {}
	__mod_data.all_hidden_markets = __mod_data.all_hidden_markets or {}
	__mod_data.all_markets = __mod_data.all_markets or {}

	link_data()

	clear_invalid_data()

	-- init_force_data(game.forces.player.index)

	for _, force in pairs(game.forces) do
		if force.valid then
			-- if #force.players > 0 then
				init_force_data(force.index)
			-- end
		end
	end

	detect_desync(game)
end

local function on_configuration_changed(event)
	update_global_data()

	-- local mod_changes = event.mod_changes["trading_system"]
	-- if not (mod_changes and mod_changes.old_version) then return end

	-- local version = tonumber(string.gmatch(mod_changes.old_version, "%d+.%d+")())
end

do
	local function set_filters()
		local filters = {
			{filter = "type", mode = "or", type = "container"},
			-- {filter = "type", mode = "or", type = "logistic-container"}
		}
		local filters_clone = {
			{filter = "type", mode = "or", type = "container"},
			{filter = "type", mode = "or", type = "market"},
			-- {filter = "type", mode = "or", type = "logistic-container"}
		}
		script.set_event_filter(defines.events.script_raised_built, filters)
		script.set_event_filter(defines.events.on_robot_built_entity, filters)
		script.set_event_filter(defines.events.on_built_entity, filters)
		script.set_event_filter(defines.events.on_entity_died, filters)
		script.set_event_filter(defines.events.on_robot_mined_entity, filters)
		script.set_event_filter(defines.events.script_raised_destroy, filters)
		script.set_event_filter(defines.events.on_player_mined_entity, filters)
		script.set_event_filter(defines.events.on_entity_cloned, filters_clone)

		local EasyAPI_events = call("EasyAPI", "get_events")
		if EasyAPI_events.on_fix_bugs then
			script.on_event(EasyAPI_events.on_fix_bugs, function()
				clear_invalid_entities()

				detect_desync(game)
			end)
		end
		if EasyAPI_events.on_sync then
			script.on_event(EasyAPI_events.on_sync, function()
				link_data()
			end)
		end
	end

	M.on_load = function()
		link_data()
		set_filters()
	end
	M.on_init = function()
		update_global_data()
		set_filters()
	end
end
M.on_configuration_changed = on_configuration_changed
M.add_remote_interface = add_remote_interface

--#endregion


M.events = {
	[defines.events.on_surface_deleted] = clear_invalid_entities,
	[defines.events.on_surface_cleared] = clear_invalid_entities,
	[defines.events.on_chunk_deleted] = clear_invalid_entities,
	[defines.events.on_player_joined_game] = M.on_player_joined_game,
	[defines.events.on_player_changed_force] = M.on_player_changed_force,
	[defines.events.on_gui_opened] = M.on_gui_opened,
	[defines.events.on_market_item_purchased] = M.on_market_item_purchased,
	[defines.events.on_force_created] = M.on_force_created,
	[defines.events.on_forces_merging] = M.on_forces_merging,
	[defines.events.script_raised_built] = M.script_raised_built,
	[defines.events.on_robot_built_entity] = M.on_built_entity,
	[defines.events.on_built_entity] = M.on_built_entity,
	[defines.events.on_entity_cloned] = M.on_entity_cloned,
	[defines.events.on_runtime_mod_setting_changed] = M.on_runtime_mod_setting_changed,
	-- [defines.events.on_entity_settings_pasted] = function(event)
	-- 	local source = event.source
	-- 	if not (source and source.valid) then return end
	-- 	local market_data = _all_markets[source.unit_number]
	-- 	if market_data == nil then return end

	-- 	local destination = event.destination
	-- 	if not (destination and destination.valid) then return end
	-- 	if destination.force ~= source.force then return end

	-- 	local player = game.get_player(event.player_index)
	-- 	if not (player and player.valid) then return end
	-- end,
	[defines.events.on_player_mined_entity] = M.clear_market_data,
	[defines.events.on_robot_mined_entity] = M.clear_market_data,
	[defines.events.script_raised_destroy] = M.clear_market_data,
	[defines.events.on_entity_died] = M.clear_market_data
}

M.on_nth_tick = {
	[_update_buy_tick] = M.check_buy_markets,
	[_update_sell_tick] = M.check_sell_markets,
}

M.commands = {
	---@param cmd CustomCommandData
	["set-sell-price-globally"] = function(cmd)
		local item_name, price = M.find_item_in_text(cmd.parameter)
		if item_name == nil then return end

		if not is_price_valid(price) then
			local player = game.get_player(cmd.player_index)
			if not (player and player.valid) then return end
			player.print("The data type allows values from 0 to 65535", {1, 0, 0}) -- TODO: add localization
			return
		end

		--#if DEBUG then
			game.print("item_name: " .. item_name .. " price: " .. tostring(price))
		--#end
		set_sell_price_globally(item_name, price)
	end,
	---@param cmd CustomCommandData
	["set-buy-price-globally"] = function(cmd)
		local item_name, price = M.find_item_in_text(cmd.parameter)
		if item_name == nil then return end

		if not is_price_valid(price) then
			local player = game.get_player(cmd.player_index)
			if not (player and player.valid) then return end
			player.print("The data type allows values from 0 to 65535",  {1, 0, 0}) -- TODO: add localization
			return
		end

		--#if DEBUG then
			game.print("item_name: " .. item_name .. " price: " .. tostring(price))
		--#end
		set_buy_price_globally(item_name, price)
	end,
	---@param cmd CustomCommandData
	["export-global-prices-for-trading-system"] = function(cmd)
		local data = helpers.table_to_json({
			global_sell_prices = __global_sell_prices,
			global_buy_prices  = __global_buy_prices
		})

		local file_name = "global-prices-for-trading-system.json"
		helpers.write_file(file_name, data, false, cmd.player_index)

		local message = "Saved data in script-output/" .. file_name
		if cmd.player_index == 0 then
			print(message)
		else
			local player = game.get_player(cmd.player_index)
			---TODO: add localization
			player.print(message)
		end
	end,
	---@param cmd CustomCommandData
	["import-global-prices-from-trading-system"] = function(cmd)
		local data = helpers.json_to_table(cmd.parameter)
		if type(data) ~= "table" or (data.global_buy_prices == nil and data.global_sell_prices == nil) then
			local message = "Invalid data"
			if cmd.player_index == 0 then
				print(message)
			else
				local player = game.get_player(cmd.player_index)
				---TODO: add localization
				player.print(message)
			end
			return
		end

		import_global_prices(nil, data)
	end,
}


return M
